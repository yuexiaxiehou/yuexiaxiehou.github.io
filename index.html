<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>自适应学习五子棋AI</title>
    <!-- 引入 Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- 引入 Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Noto Sans SC', sans-serif;
            overflow: hidden; /* 防止出现滚动条 */
        }
        /* 玻璃拟态效果 */
        .glass-panel {
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.15);
        }
        .btn-interactive {
            transition: all 0.2s ease;
        }
        .btn-interactive:active {
            transform: scale(0.95);
        }
        /* 棋子阴影效果 */
        .piece-shadow {
            filter: drop-shadow(2px 4px 6px rgba(0,0,0,0.3));
        }
    </style>
</head>
<body class="h-screen w-screen bg-gradient-to-br from-blue-900 via-teal-800 to-green-800 text-white flex items-center justify-center p-4">

    <!-- 主布局容器 -->
    <div class="w-full max-w-6xl h-[90vh] grid grid-cols-1 lg:grid-cols-12 gap-6">
        
        <!-- 左侧：游戏区域 (占 8 列) -->
        <div class="lg:col-span-8 flex flex-col glass-panel rounded-3xl p-6 relative">
            <!-- 标题 -->
            <div class="flex justify-between items-center mb-4">
                <h1 class="text-3xl font-bold tracking-wider text-transparent bg-clip-text bg-gradient-to-r from-cyan-300 to-green-300">
                    自适应学习五子棋AI
                </h1>
                <!-- 状态指示 -->
                <div id="status-display" class="px-4 py-1 rounded-full bg-white/10 border border-white/20 text-sm font-medium animate-pulse">
                    准备就绪
                </div>
            </div>

            <!-- Canvas 容器 -->
            <div class="flex-1 flex items-center justify-center bg-gradient-to-b from-amber-100 to-amber-200 rounded-2xl shadow-inner relative overflow-hidden" id="canvas-container">
                <canvas id="gameCanvas" width="600" height="600" class="cursor-pointer shadow-2xl rounded-lg"></canvas>
                
                <!-- 获胜遮罩层 -->
                <div id="winner-modal" class="absolute inset-0 bg-black/60 backdrop-blur-sm flex items-center justify-center hidden opacity-0 transition-opacity duration-500 z-10">
                    <div class="text-center transform scale-0 transition-transform duration-500" id="winner-content">
                        <h2 class="text-5xl font-bold mb-2 text-white drop-shadow-lg" id="winner-text">玩家获胜!</h2>
                        <p class="text-gray-200 mb-6">AI 正在分析你的策略...</p>
                        <button onclick="game.resetGame()" class="px-6 py-2 bg-cyan-500 hover:bg-cyan-400 text-white rounded-full font-bold shadow-lg btn-interactive">
                            再来一局
                        </button>
                    </div>
                </div>
            </div>
            
            <div class="mt-2 text-center text-white/50 text-xs">
                提示：玩家执黑先行，点击棋盘交点落子
            </div>
        </div>

        <!-- 右侧：控制面板 (占 4 列) -->
        <div class="lg:col-span-4 flex flex-col gap-4">
            
            <!-- 控制按钮卡片 -->
            <div class="glass-panel rounded-2xl p-6 flex flex-col gap-3">
                <h2 class="text-xl font-bold mb-2 text-cyan-100">控制中心</h2>
                
                <button onclick="game.resetGame()" class="btn-interactive w-full py-3 bg-gradient-to-r from-blue-600 to-blue-500 rounded-xl font-bold shadow-lg hover:shadow-blue-500/30 flex items-center justify-center gap-2">
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path></svg>
                    新游戏
                </button>

                <button id="toggle-learn-btn" onclick="ai.toggleLearningMode()" class="btn-interactive w-full py-3 bg-gradient-to-r from-emerald-600 to-teal-600 rounded-xl font-bold shadow-lg hover:shadow-emerald-500/30 flex items-center justify-center gap-2">
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z"></path></svg>
                    <span id="learn-btn-text">启用学习模式</span>
                </button>

                <button onclick="ai.manualTrain()" class="btn-interactive w-full py-3 bg-gradient-to-r from-purple-600 to-indigo-600 rounded-xl font-bold shadow-lg hover:shadow-purple-500/30 flex items-center justify-center gap-2">
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19.428 15.428a2 2 0 00-1.022-.547l-2.384-.477a6 6 0 00-3.86.517l-.318.158a6 6 0 01-3.86.517L6.05 15.21a2 2 0 00-1.806.547M8 4h8l-1 1v5.172a2 2 0 00.586 1.414l5 5c1.26 1.26.367 3.414-1.415 3.414H4.828c-1.782 0-2.674-2.154-1.414-3.414l5-5A2 2 0 009 10.172V5L8 4z"></path></svg>
                    训练 AI
                </button>

                <button onclick="ai.resetKnowledge()" class="btn-interactive w-full py-3 bg-gradient-to-r from-red-600 to-pink-600 rounded-xl font-bold shadow-lg hover:shadow-red-500/30 flex items-center justify-center gap-2">
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path></svg>
                    重置 AI 知识
                </button>
            </div>

            <!-- 统计与状态卡片 -->
            <div class="glass-panel rounded-2xl p-6 flex-1 flex flex-col justify-between">
                <div>
                    <h2 class="text-xl font-bold mb-4 text-cyan-100">AI 状态监控</h2>
                    
                    <div class="space-y-4">
                        <div class="bg-white/5 rounded-lg p-3 border border-white/10">
                            <div class="text-sm text-gray-300">对战统计</div>
                            <div class="flex justify-between items-end mt-1">
                                <div class="text-2xl font-bold text-green-400" id="stat-wins">0</div>
                                <div class="text-xs text-gray-400">AI 胜场</div>
                            </div>
                        </div>

                        <div class="bg-white/5 rounded-lg p-3 border border-white/10">
                            <div class="text-sm text-gray-300">AI 胜率</div>
                            <div class="flex justify-between items-end mt-1">
                                <div class="text-2xl font-bold text-blue-400" id="stat-winrate">0%</div>
                                <div class="w-24 h-2 bg-gray-700 rounded-full overflow-hidden">
                                    <div id="stat-bar" class="h-full bg-blue-500 w-0 transition-all duration-500"></div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="mt-6 p-4 rounded-xl bg-black/20 border border-white/5">
                    <div class="flex items-center gap-3">
                        <div id="ai-status-indicator" class="w-3 h-3 rounded-full bg-gray-500 shadow-[0_0_8px_rgba(107,114,128,0.6)]"></div>
                        <span id="ai-status-text" class="text-sm font-medium">学习模式：已关闭</span>
                    </div>
                    <div class="mt-2 text-xs text-gray-400 leading-relaxed">
                        AI 会记住让你获胜的步骤，并在下次训练时尝试避免。
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        /**
         * 游戏常量定义
         */
        const BOARD_SIZE = 15;
        const EMPTY = 0;
        const BLACK = 1; // 玩家
        const WHITE = 2; // AI

        /**
         * AI 核心类：负责决策、学习和记忆
         */
        class GomokuAI {
            constructor() {
                this.knowledgeBase = this.loadKnowledge();
                this.isLearning = false;
                this.playerHistory = []; // 记录当前对局玩家的走法
                this.learningData = {
                    playerWins: 0,
                    aiWins: 0,
                    totalGames: 0
                };
            }

            // 从 LocalStorage 加载数据
            loadKnowledge() {
                const saved = localStorage.getItem('gomoku_ai_brain');
                if (saved) {
                    try {
                        const parsed = JSON.parse(saved);
                        if (parsed.stats) this.learningData = parsed.stats;
                        return parsed.heatmap || {};
                    } catch (e) {
                        console.error("知识库加载失败，重置为空");
                    }
                }
                return {};
            }

            // 保存数据到 LocalStorage
            saveKnowledge() {
                const data = {
                    heatmap: this.knowledgeBase,
                    stats: this.learningData
                };
                localStorage.setItem('gomoku_ai_brain', JSON.stringify(data));
                ui.updateStats(this.learningData);
            }

            toggleLearningMode() {
                this.isLearning = !this.isLearning;
                ui.toggleLearningBtn(this.isLearning);
                this.saveKnowledge(); // 仅为了触发 UI 更新状态指示灯
            }

            resetKnowledge() {
                if(confirm("确定要清除 AI 所有的学习记忆吗？这将无法恢复。")) {
                    this.knowledgeBase = {};
                    this.learningData = { playerWins: 0, aiWins: 0, totalGames: 0 };
                    this.saveKnowledge();
                    ui.showToast("AI 记忆已清除");
                }
            }

            // 记录玩家的落子，用于后续学习
            recordPlayerMove(r, c) {
                if (this.isLearning) {
                    // 将棋盘状态编码为字符串 key
                    const boardState = game.board.map(row => row.join('')).join('');
                    const key = `${boardState}|${r},${c}`;
                    this.playerHistory.push(key);
                }
            }

            // 当 AI 获胜时，清除当前记录（因为 AI 赢了，说明玩家策略有问题，不需要特别学习“避免”）
            onAIWin() {
                this.learningData.aiWins++;
                this.learningData.totalGames++;
                this.playerHistory = [];
                this.saveKnowledge();
            }

            // 当玩家获胜时，惩罚 AI 的表现（学习模式）
            onPlayerWin() {
                this.learningData.playerWins++;
                this.learningData.totalGames++;
                
                if (this.isLearning) {
                    // 玩家赢了，说明 AI 在某个步骤选择不好，或者玩家在某个局面对 AI 构成了威胁
                    // 这里我们增加玩家获胜路径的权重，让 AI 在下次面对类似局面时，优先考虑防守这些点
                    this.playerHistory.forEach(key => {
                        if (!this.knowledgeBase[key]) this.knowledgeBase[key] = 0;
                        this.knowledgeBase[key] += 10; // 增加权重：AI 下次应该警惕这个点
                    });
                    ui.showToast("AI 正在分析你的获胜策略...", 2000);
                }
                
                this.playerHistory = [];
                this.saveKnowledge();
            }

            manualTrain() {
                const count = Object.keys(this.knowledgeBase).length;
                if (count === 0) {
                    ui.showToast("AI 暂无学习数据，请先开启学习模式并对战几局。");
                } else {
                    // 模拟训练过程
                    ui.showToast(`AI 正在深度训练 ${count} 个样本...`);
                    setTimeout(() => {
                        ui.showToast("训练完成！AI 策略已优化。");
                    }, 1500);
                }
            }

            // 计算最佳落子点
            getBestMove(board) {
                let bestScore = -Infinity;
                let bestMoves = [];

                // 简单的评分系统
                // 1. 进攻分：如果我下这，我能连多少？
                // 2. 防守分：如果我不下这，对方能连多少？
                // 3. 学习分：知识库中记录的威胁点

                for (let r = 0; r < BOARD_SIZE; r++) {
                    for (let c = 0; c < BOARD_SIZE; c++) {
                        if (board[r][c] === EMPTY) {
                            // 剪枝优化：只考虑周围有棋子的空位
                            if (!game.hasNeighbor(r, c)) continue;

                            const attackScore = this.evaluatePosition(board, r, c, WHITE);
                            const defenseScore = this.evaluatePosition(board, r, c, BLACK);
                            
                            // 获取学习分（如果有）
                            const boardStateStr = board.map(row => row.join('')).join('');
                            const learnKey = `${boardStateStr}|${r},${c}`;
                            const learnBonus = this.knowledgeBase[learnKey] || 0;

                            // 综合评分：防守通常比进攻重要，除非自己能直接赢
                            // 这里的系数可以调整
                            let currentScore = (attackScore * 1.0) + (defenseScore * 1.1) + (learnBonus * 2.0);

                            // 五连优先级最高
                            if (attackScore >= 100000) currentScore = 200000; 
                            else if (defenseScore >= 100000) currentScore = 150000; // 必防

                            if (currentScore > bestScore) {
                                bestScore = currentScore;
                                bestMoves = [{r, c}];
                            } else if (currentScore === bestScore) {
                                bestMoves.push({r, c});
                            }
                        }
                    }
                }

                // 如果没有找到合适的点（比如第一步），下在天元附近
                if (bestMoves.length === 0) {
                    return { r: 7, c: 7 };
                }

                // 随机选择一个最高分的点，增加变化
                const move = bestMoves[Math.floor(Math.random() * bestMoves.length)];
                return move;
            }

            // 评估某个位置对于某方的分数
            evaluatePosition(board, r, c, player) {
                let score = 0;
                // 四个方向：横、竖、左斜、右斜
                const directions = [[1, 0], [0, 1], [1, 1], [1, -1]];

                for (let [dr, dc] of directions) {
                    let count = 1; // 当前落子算1个
                    let blocked = 0;

                    // 正向检查
                    for (let i = 1; i < 5; i++) {
                        const nr = r + dr * i;
                        const nc = c + dc * i;
                        if (nr < 0 || nr >= BOARD_SIZE || nc < 0 || nc >= BOARD_SIZE) {
                            blocked++;
                            break;
                        }
                        if (board[nr][nc] === player) {
                            count++;
                        } else if (board[nr][nc] === EMPTY) {
                            break;
                        } else {
                            blocked++;
                            break;
                        }
                    }

                    // 反向检查
                    for (let i = 1; i < 5; i++) {
                        const nr = r - dr * i;
                        const nc = c - dc * i;
                        if (nr < 0 || nr >= BOARD_SIZE || nc < 0 || nc >= BOARD_SIZE) {
                            blocked++;
                            break;
                        }
                        if (board[nr][nc] === player) {
                            count++;
                        } else if (board[nr][nc] === EMPTY) {
                            break;
                        } else {
                            blocked++;
                            break;
                        }
                    }

                    // 评分规则
                    if (count >= 5) score += 100000; // 成五
                    else if (count === 4) {
                        if (blocked === 0) score += 10000; // 活四
                        else if (blocked === 1) score += 1000; // 冲四
                    } else if (count === 3) {
                        if (blocked === 0) score += 1000; // 活三
                        else if (blocked === 1) score += 100; // 眠三
                    } else if (count === 2) {
                        if (blocked === 0) score += 100; // 活二
                    }
                }
                return score;
            }
        }

        /**
         * 游戏控制类：处理 Canvas 逻辑和游戏状态
         */
        class Game {
            constructor(canvasId) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');
                this.board = [];
                this.currentPlayer = BLACK;
                this.gameOver = false;
                this.cellSize = 0;
                this.padding = 30;
                
                this.resizeCanvas();
                window.addEventListener('resize', () => {
                    this.resizeCanvas();
                    this.draw();
                });

                this.canvas.addEventListener('click', (e) => this.handleClick(e));
                this.initBoard();
            }

            resizeCanvas() {
                const container = this.canvas.parentElement;
                const size = Math.min(container.clientWidth, container.clientHeight);
                // 设置内部分辨率为清晰度
                this.canvas.width = size;
                this.canvas.height = size;
                this.cellSize = (size - 2 * this.padding) / (BOARD_SIZE - 1);
            }

            initBoard() {
                this.board = Array(BOARD_SIZE).fill(null).map(() => Array(BOARD_SIZE).fill(EMPTY));
                this.currentPlayer = BLACK;
                this.gameOver = false;
                ai.playerHistory = [];
                this.draw();
                ui.setStatus("玩家执黑先行");
            }

            resetGame() {
                ui.hideModal();
                this.initBoard();
            }

            hasNeighbor(r, c) {
                const range = 2;
                for (let i = r - range; i <= r + range; i++) {
                    for (let j = c - range; j <= c + range; j++) {
                        if (i >= 0 && i < BOARD_SIZE && j >= 0 && j < BOARD_SIZE) {
                            if (this.board[i][j] !== EMPTY) return true;
                        }
                    }
                }
                return false;
            }

            handleClick(e) {
                if (this.gameOver || this.currentPlayer !== BLACK) return;

                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                // 计算最近的交叉点索引
                const col = Math.round((x - this.padding) / this.cellSize);
                const row = Math.round((y - this.padding) / this.cellSize);

                if (row >= 0 && row < BOARD_SIZE && col >= 0 && col < BOARD_SIZE) {
                    if (this.board[row][col] === EMPTY) {
                        this.makeMove(row, col, BLACK);
                    }
                }
            }

            makeMove(row, col, player) {
                this.board[row][col] = player;
                
                // 记录数据
                if (player === BLACK) {
                    ai.recordPlayerMove(row, col);
                }

                this.draw(); // 绘制棋子

                if (this.checkWin(row, col, player)) {
                    this.endGame(player);
                    return;
                }

                // 切换回合
                if (player === BLACK) {
                    this.currentPlayer = WHITE;
                    ui.setStatus("AI 思考中...");
                    // 稍微延迟，让 UI 渲染出来，模拟思考
                    setTimeout(() => {
                        const move = ai.getBestMove(this.board);
                        this.makeMove(move.r, move.c, WHITE);
                    }, 300);
                } else {
                    this.currentPlayer = BLACK;
                    ui.setStatus("玩家回合");
                }
            }

            checkWin(row, col, player) {
                const directions = [[1, 0], [0, 1], [1, 1], [1, -1]];
                for (let [dr, dc] of directions) {
                    let count = 1;
                    // 正向
                    for (let i = 1; i < 5; i++) {
                        const nr = row + dr * i;
                        const nc = col + dc * i;
                        if (nr >= 0 && nr < BOARD_SIZE && nc >= 0 && nc < BOARD_SIZE && this.board[nr][nc] === player) count++;
                        else break;
                    }
                    // 反向
                    for (let i = 1; i < 5; i++) {
                        const nr = row - dr * i;
                        const nc = col - dc * i;
                        if (nr >= 0 && nr < BOARD_SIZE && nc >= 0 && nc < BOARD_SIZE && this.board[nr][nc] === player) count++;
                        else break;
                    }
                    if (count >= 5) return true;
                }
                return false;
            }

            endGame(winner) {
                this.gameOver = true;
                const modal = document.getElementById('winner-modal');
                const content = document.getElementById('winner-content');
                const text = document.getElementById('winner-text');

                modal.classList.remove('hidden');
                // 强制重绘以触发 transition
                void modal.offsetWidth;
                modal.classList.remove('opacity-0');
                content.classList.remove('scale-0');

                if (winner === BLACK) {
                    text.innerText = "玩家获胜!";
                    text.className = "text-5xl font-bold mb-2 text-transparent bg-clip-text bg-gradient-to-r from-yellow-300 to-amber-500 drop-shadow-md";
                    ai.onPlayerWin();
                } else {
                    text.innerText = "AI 获胜!";
                    text.className = "text-5xl font-bold mb-2 text-cyan-300 drop-shadow-md";
                    ai.onAIWin();
                }
            }

            draw() {
                // 清空画布
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

                // 1. 绘制网格
                this.ctx.beginPath();
                this.ctx.lineWidth = 1;
                this.ctx.strokeStyle = '#8B4513'; // 深褐色线条
                
                for (let i = 0; i < BOARD_SIZE; i++) {
                    const pos = this.padding + i * this.cellSize;
                    // 横线
                    this.ctx.moveTo(this.padding, pos);
                    this.ctx.lineTo(this.canvas.width - this.padding, pos);
                    // 竖线
                    this.ctx.moveTo(pos, this.padding);
                    this.ctx.lineTo(pos, this.canvas.height - this.padding);
                }
                this.ctx.stroke();

                // 绘制天元和星位 (标准15路棋盘)
                const stars = [3, 7, 11];
                this.ctx.fillStyle = '#8B4513';
                for (let r of stars) {
                    for (let c of stars) {
                        const x = this.padding + c * this.cellSize;
                        const y = this.padding + r * this.cellSize;
                        this.ctx.beginPath();
                        this.ctx.arc(x, y, 3, 0, Math.PI * 2);
                        this.ctx.fill();
                    }
                }

                // 2. 绘制棋子
                for (let r = 0; r < BOARD_SIZE; r++) {
                    for (let c = 0; c < BOARD_SIZE; c++) {
                        if (this.board[r][c] !== EMPTY) {
                            this.drawPiece(r, c, this.board[r][c]);
                        }
                    }
                }

                // 3. 标记最后一步
                // (可选，可以增加一个红点标记最后落子位置)
            }

            drawPiece(row, col, type) {
                const x = this.padding + col * this.cellSize;
                const y = this.padding + row * this.cellSize;
                const radius = this.cellSize * 0.42;

                this.ctx.beginPath();
                this.ctx.arc(x, y, radius, 0, Math.PI * 2);

                // 棋子渐变效果
                const gradient = this.ctx.createRadialGradient(x - radius/3, y - radius/3, radius/10, x, y, radius);
                
                if (type === BLACK) {
                    gradient.addColorStop(0, '#666');
                    gradient.addColorStop(1, '#000');
                    // 阴影
                    this.ctx.shadowColor = 'rgba(0,0,0,0.5)';
                    this.ctx.shadowBlur = 4;
                    this.ctx.shadowOffsetX = 2;
                    this.ctx.shadowOffsetY = 2;
                } else {
                    gradient.addColorStop(0, '#fff');
                    gradient.addColorStop(1, '#ddd');
                    this.ctx.shadowColor = 'rgba(0,0,0,0.2)';
                    this.ctx.shadowBlur = 4;
                    this.ctx.shadowOffsetX = 2;
                    this.ctx.shadowOffsetY = 2;
                }

                this.ctx.fillStyle = gradient;
                this.ctx.fill();

                // 重置阴影以免影响网格
                this.ctx.shadowColor = 'transparent';
            }
        }

        /**
         * UI 管理类
         */
        class UIManager {
            setStatus(msg) {
                const el = document.getElementById('status-display');
                el.innerText = msg;
                // 简单闪烁动画重置
                el.classList.remove('animate-pulse');
                void el.offsetWidth;
                el.classList.add('animate-pulse');
            }

            updateStats(stats) {
                document.getElementById('stat-wins').innerText = stats.aiWins;
                const rate = stats.totalGames === 0 ? 0 : Math.round((stats.aiWins / stats.totalGames) * 100);
                document.getElementById('stat-winrate').innerText = rate + '%';
                document.getElementById('stat-bar').style.width = rate + '%';
            }

            toggleLearningBtn(isEnabled) {
                const btn = document.getElementById('toggle-learn-btn');
                const text = document.getElementById('learn-btn-text');
                const indicator = document.getElementById('ai-status-indicator');
                const statusText = document.getElementById('ai-status-text');

                if (isEnabled) {
                    text.innerText = "学习模式：已开启";
                    btn.classList.remove('from-emerald-600', 'to-teal-600');
                    btn.classList.add('from-yellow-500', 'to-orange-500');
                    indicator.classList.remove('bg-gray-500');
                    indicator.classList.add('bg-green-400', 'shadow-[0_0_8px_rgba(74,222,128,0.8)]');
                    statusText.innerText = "学习模式：已开启";
                    statusText.classList.add('text-green-400');
                } else {
                    text.innerText = "启用学习模式";
                    btn.classList.add('from-emerald-600', 'to-teal-600');
                    btn.classList.remove('from-yellow-500', 'to-orange-500');
                    indicator.classList.add('bg-gray-500');
                    indicator.classList.remove('bg-green-400', 'shadow-[0_0_8px_rgba(74,222,128,0.8)]');
                    statusText.innerText = "学习模式：已关闭";
                    statusText.classList.remove('text-green-400');
                }
            }

            hideModal() {
                const modal = document.getElementById('winner-modal');
                const content = document.getElementById('winner-content');
                modal.classList.add('opacity-0');
                content.classList.add('scale-0');
                setTimeout(() => {
                    modal.classList.add('hidden');
                }, 500);
            }

            showToast(message, duration = 3000) {
                // 创建一个临时 toast 元素
                const toast = document.createElement('div');
                toast.className = 'fixed top-8 left-1/2 transform -translate-x-1/2 bg-white/90 text-black px-6 py-3 rounded-full shadow-2xl z-50 font-bold transition-all duration-300 opacity-0 translate-y-[-20px]';
                toast.innerText = message;
                document.body.appendChild(toast);

                // 动画进入
                requestAnimationFrame(() => {
                    toast.classList.remove('opacity-0', 'translate-y-[-20px]');
                });

                // 自动消失
                setTimeout(() => {
                    toast.classList.add('opacity-0', 'translate-y-[-20px]');
                    setTimeout(() => toast.remove(), 300);
                }, duration);
            }
        }

        // 初始化
        const ui = new UIManager();
        const ai = new GomokuAI();
        const game = new Game('gameCanvas');

        // 初始加载状态
        ui.updateStats(ai.learningData);
        if (ai.isLearning) ui.toggleLearningBtn(true);

    </script>
</body>
</html>
